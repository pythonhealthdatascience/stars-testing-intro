---
title: "Back tests"
---

```{r}
#| include: false
library(reticulate)
use_condaenv("stars-testing-intro", required = TRUE)
```

{{< include /assets/language-selector.html >}}

<br>

## What is a back test?

A **back** test involves running your workflow on historical data and confirming that results are consistent over time.

It's not focused on whether results are theoretically correct. It's about **consistency and reproducibility** - confirming that code changes, environment updates, or data pipeline tweaks have not silently changed results.

This overlaps with functional testing, but is distinct, because functional tests ask "is this output *correct*" whereas back tests ask "is this output *the same as before*?".

## Example: waiting times case study

We will run back tests using the [dataset we introduced for our waiting times case study](case_study.qmd).

::: {.python-content}

On the test page, we need to import:

```{python}
#| eval: false
#| file: code/test_back__imports.py
```

:::

## Back test

::: {.python-content}

```{python}
#| eval: false
#| file: code/test_back__test_reproduction.py
```

:::

::: {.r-content}

```{r}
#| eval: false
#| file: code/test_back__re_running_on_historical.R
```

:::

## Running our example test

:::: {.callout-note title="Test output"}

::: {.python-content}

```{python}
#| echo: false
import pytest
pytest.main(["../examples/python_package/tests/test_back.py"])
```

:::

::: {.r-content}

```{r}
#| echo: false
#| output: false
devtools::load_all("../examples/r_package")
```

```{r}
#| echo: false
testthat::test_file(
  "../examples/r_package/tests/testthat/test_back.R"
)
```

:::

::::

## When should you update your back tests?

**Errors:** If you identify an error in your pipeline, you first fix the code and then deliberately update the back test in isolation, so you know the only change in behaviour is the error fix and not something unintended elsewhere.

**Changes over time:** As your research evolves, you may update the workflow (e.g., improve the wait time calculation method) or use more recent datasets. You can keep the old back test running alongside new ones - this verifies that changes to the workflow don't accidentally alter results on historical data, while new back tests validate that updated methods work correctly on current data.