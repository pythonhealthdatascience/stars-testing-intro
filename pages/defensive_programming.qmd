--
title: "Defensive Programming"
---

```{r}
#| include: false
library(reticulate)
use_condaenv("hdruk_tests", required = TRUE)
```

{{< include /assets/language-selector.html >}}

<br>

## What is defensive programming?

**Defensive programming** is a proactive approach to software development that anticipates potential failures, invalid inputs, and unexpected conditions before they occur. Rather than assuming code will receive perfect inputs and execute under ideal conditions, it operates on the principle that "anything that can go wrong will go wrong." The goal is to write code that detects problems early, handles them gracefully, and maintains system stability even when circumstances are unforeseen.

This approach is particularly valuable in research code that may be reused by other researchers or even yourself in the future.  It aims to prevent another user (even yourself 5 years from now) from introducing a silent mistake into their analyses. These mistakes might be from implicit assumptions about data format, combinations of settings, invalid data ranges, or even the type of data structures used.

By building in safeguards from the start, defensive programming significantly reduces bugs, improves reliability, and makes software behavior more predictable. If planned out carefully the practice will ultimately save debugging time and preventing costly failures.

Testing of code and defensive programming are complementary practices that work together to create robust software. While defensive programming builds safeguards directly into the code, the testing methods we have described verify that these safeguards work as intended. 

> 

## Example: calculating waiting times

We will return to our [waiting times case study](case_study.qmd) and in particular the `calculate_wait_times()` function.

