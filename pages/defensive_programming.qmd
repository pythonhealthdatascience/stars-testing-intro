--
title: "Defensive Programming"
---

```{r}
#| include: false
library(reticulate)
use_condaenv("hdruk_tests", required = TRUE)
```

{{< include /assets/language-selector.html >}}

<br>

## What is defensive programming?

**Defensive programming** is a proactive approach to software development that anticipates potential failures, invalid inputs, and unexpected conditions before they occur. Rather than assuming code will receive perfect inputs and execute under ideal conditions, it operates on the principle that "anything that can go wrong will go wrong." The goal is to write code that detects problems early, handles them gracefully, and maintains system stability even when circumstances are unforeseen.

This approach is particularly valuable in research code that may be reused by other researchers or even yourself in the future.  It aims to prevent another user (even yourself 5 years from now) from introducing a silent mistake into their analyses. These mistakes might be from implicit assumptions about data format, combinations of settings, invalid data ranges, or even the type of data structures used.

By building in safeguards from the start, defensive programming significantly reduces bugs, improves reliability, and makes software behavior more predictable. If planned out carefully the practice will ultimately save debugging time and preventing costly failures.

Testing of code and defensive programming are complementary practices that work together to create robust software. While defensive programming builds safeguards directly into the code, the testing methods we have described verify that these safeguards work as intended. 


## Example: calculating waiting times

We will return to our [waiting times case study](case_study.qmd) and in particular the `calculate_wait_times()` function.

::: {.python-content}

As a reminder this was our original code for the `calculate_wait_times()` function.

```{python}
import pandas as pd
import warnings
```


```{python}
#| eval: false
#| file: code/patient_analysis__calculate_wait_times.py
```

:::

## 1. Protect your code from invalid and edge case inputs 

<div class="h3-tight"></div>

Here are some **minimal** defensive changes we could make to `calculate_wait_times()` 

* Raise an exception if the `df` parameter passed to the function is not of type dataframe. 
* Raise an exception if the `df` parameter does not have one or more of the expected columns within it.
* If `df` is the edge case that does not contain any data (rows) warn the user and return an empty dataframe instead of attempting to perform a calculation (return early). 

These three examples demonstrate two approaches to handling invalid inputs. The first two errors modes are handled with a **hard stop**. Typically this done by raising an exception, a specific type of error, and stopping the program from executing futher. It is important to provide a clear error message to the user to help them fix the mistake.

The third type of input is an edge case where the dataframe is a valid format, but is empty.  This might happen in unusual circumstances where there were no patients on a particular date.  To handle this scenario, you could choose to raise an exception, but if this is a legitimate edge case you may choose to **return early** i.e. return an empty dataframe. his is a way to gracefully handle the edge case before any data processing takes place that would otherwise generate runtime errors.  As well as returning early, you may decide to warn the user that they passed in an empty dataframe and return an empty result.  The approach means that the function still fullfills its contract i.e. returns an appropriate datatype, but prevents data processing errors.  

::: {.python-content}

Here is an implementation of those three points in Python

The first two issues are dealt with through structured exception handling. A `TypeError` is raised if anything other than a dataframe is passed to the function. An `ValueError` is raised if the columns (values) of the dataframe are not as expected.

We handle the edge case of an empty dataframe through the combination of an `if` statement, the python warnings package, and an early return.

Two extra considerations to help the user (which again might be you in the future!):

1. Update the docstring of your function to detail the exceptions that can be raised and why.
2. Try as best you can to provide user friendly error messages to help fix mistakes (not easy!).



```{python}
#| eval: false
#| file: code/defensive_programming__calculate_wait_times_1.py
```
:::

## 2.  Write tests to check that the defensive code works as expected. 

Once you've added defensive programming safeguards to your code, it's essential to verify they work correctly. This is where the testing approaches we've covered earlier come into play.  Note we are testing for "negative" behaviour here. That the code fails as we expect.

Here are some examples to test the defensive additions to `calculate_wait_times()`

*  Test that passing a different data structure than a DataFrame raises the appropraite error and message.
*  Test that passing a DataFrame missing one or more required columns raises the appropraite error and message.
*  Test that an empty DataFrame returns the correct structure with arrival_datetime, service_datetime, and waittime columns
*  If implemented, test that an empty DataFrame with valid column triggers a warning


## 3. What else could we do defensively?

The example we provide here only scratches the surface of defensive programming.  We have introduced guardrails for our inputs, but the data within them could also be **garbage**. For example, the function expects date time data to be in a specific format.  Our `df` with a different format might fail in unexpected ways, potentially causing a runtime error, or even worse silently!  

There is only so much time you have available to write defensive code, and deciding what to guard against is critical.  This is why testing your code is so important.  If, for example, you test your code and find it fails silently i.e. no error message, then you should strongly consider introducing a defensive programming routine to prevent that from happening in the future.

> Remember: the goal is not to defensively program against every conceivable scenario, but to protect against the most likely errors and those with the most serious consequences for your research results.