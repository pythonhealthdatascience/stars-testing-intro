--
title: "Defensive Programming"
---

```{r}
#| include: false
library(reticulate)
use_condaenv("hdruk_tests", required = TRUE)
```

{{< include /assets/language-selector.html >}}

<br>

## What is defensive programming?

**Defensive programming** is a proactive approach to software development that anticipates potential failures, invalid inputs, and unexpected conditions before they occur. Rather than assuming code will receive perfect inputs and execute under ideal conditions, it operates on the principle that "anything that can go wrong will go wrong." The goal is to write code that detects problems early, handles them gracefully, and maintains system stability even when circumstances are unforeseen.

This approach is particularly valuable in research code that may be reused by other researchers or even yourself in the future.  It aims to prevent another user (even yourself 5 years from now) from introducing a silent mistake into their analyses. These mistakes might be from implicit assumptions about data format, combinations of settings, invalid data ranges, or even the type of data structures used.

By building in safeguards from the start, defensive programming significantly reduces bugs, improves reliability, and makes software behavior more predictable. If planned out carefully the practice will ultimately save debugging time and preventing costly failures.

Testing of code and defensive programming are complementary practices that work together to create robust software. While defensive programming builds safeguards directly into the code, the testing methods we have described verify that these safeguards work as intended. 


## Example: calculating waiting times

We will return to our [waiting times case study](case_study.qmd) and in particular the `calculate_wait_times()` function.

::: {.python-content}

As a reminder this was our original code for the `calculate_wait_times()` function.

```{python}
import pandas as pd
import warnings
```


```{python}
#| eval: false
#| file: code/patient_analysis__calculate_wait_times.py
```

:::

## 1. Protect your code from invalid and edge case inputs 

<div class="h3-tight"></div>

Here are some minimal defensive changes we could make to `calculate_wait_times()` 

* Raise an exception if the `df` parameter passed to the function is not of type dataframe. 
* Raise an exception if the `df` parameter does not have one or more of the expected columns within it.
* If `df` does not contain any data (rows) warn the user and return an empty dataframe (return early). 

These three examples demonstrate two approaches to handling invalid inputs. The first two errors modes are handled with a **hard stop**. Typically this done by raising an exception, a specific type of error, and stopping the program from executing futher. It is important to provide a clear error message to the user to help them fix the mistake.

The third type of input is an edge case where the dataframe is a valid format, but is empty.  This might happen in unusual circumstances where there were no patients on a particular date.  To handle this scenario, you could choose to raise an exception, but if this is a legitimate edge case you may choose to **return early** i.e. return an empty dataframe. This is a way to gracefully handle the edge case before any data processing, that would generate run time errors, take place.  As well as returning early, you may decide to warn the user that they passed in an empty dataframe and return an empty result.  The approach means that the function still fullfills its contract i.e. returns an appropriate datatype, but prevents data processing errors.  


