---
title: "How to run tests"
---

```{r}
#| include: false
library(reticulate)
use_condaenv("hdruk_tests", required = TRUE)
```

{{< include /assets/language-selector.html >}}

<br>

The approach to running tests depends on your project structure and workflow. This includes:

* Running tests when code is structured as a package.
* Running tests when code is in separate files but not a package.
* Running tests in the same file as code.

## Running tests when code is structured as a package

### Structuring research as a package

We recommend organising your research code as a package because it makes your project easier to manage, test and reuse. Benefits include:

* Your code can be installed and used anywhere in your directory (or other directories) without needing to manually set system paths.
* It encourages a clean, well-organised repository that follows standard, established conventions.
* It separates your core analysis code from inputs and outputs and experimental stuff, improving maintainability, reusability, and reducing the risk of unintended interactions.
* It integrates smoothly with automated testing frameworks - the focus of this tutorial!

If you're unfamiliar with how to set up a package, check out [our tutorial on packaging your research project](https://pythonhealthdatascience.github.io/des_rap_book/pages/guide/setup/package.html).

::: {.python-content}

When your code is part of a package, you can follow a standardised structure that pytest will automatically recognised. Tests are stored in a `tests/` folder in files whose names start with `test_`. These are automatically discovered and run by pytest.

In our example, we put together package, looks like:

```
research_project/
â”œâ”€â”€ data/
â”‚   â””â”€â”€ patient_data.csv
â”œâ”€â”€ pyproject.toml
â”œâ”€â”€ README.md
â”œâ”€â”€ src/
â”‚   â””â”€â”€ waitingtimes/
â”‚       â”œâ”€â”€ __init__.py
â”‚       â””â”€â”€ patient_analysis.py
â””â”€â”€ tests/
    â”œâ”€â”€ test_intro_simple.py
    â””â”€â”€ ...
```

### Running tests from the command line

You can run your tests from a terminal, PowerShell, or command prompt (depending on your OS). Common commands include:

```{.bash}
# Run all tests in the current directory and subdirectories
pytest

# Run all tests in the tests/ directory
pytest tests/

# Run tests from a specific file
pytest tests/test_filename.py

# Run a specific test function
pytest tests/test_filename.py::test_function_name
```

### Example demonstration

The video below demonstrates this process on a Linux system, but the same principles apply on other platforms.

In the video, we:

* Use `tree` to display the file structure (matches that shown above).
* Activate our environment: `conda activate hdruk_tests` (which includes pytest).
* Install our local package (if not already installed): `pip install -e .`.
* Verify the installation with `conda list`, confirming our `waitingtimes` package appears.
* Show you the test file (`nano tests/test_intro_simple.py`) (matches the one from the previous page on writing basic tests).
* Run the test with `pytest tests/test_intro_simple.py` - and it passes! ðŸŽ‰

{{< video /videos/run_tests_python_package.webm >}}

:::

::: {.r-content}

Tests are stored in `tests/testthat/` in files starting with `test_`. These are automatically discovered and run by testthat. For example:

```
research_project/
â”œâ”€â”€ DESCRIPTION
â”œâ”€â”€ NAMESPACE
â”œâ”€â”€ README.md
â”œâ”€â”€ R/
â”‚   â”œâ”€â”€ analysis.R
â”‚   â””â”€â”€ utils.R
â””â”€â”€ tests/
    â””â”€â”€ testthat/
        â”œâ”€â”€ test-analysis.R
        â””â”€â”€ test-utils.R
```

Tests are typically run from the R console using the following commands...

```{.r}
# Run all tests in a package
devtools::test()

# Run all tests in the current directory and subdirectories
testthat::test_dir()

# Run tests from a specific file
testthat:test_file("tests/testthat/test-filename.R")
```

When tests run, you'll see console output indicating the number of tests passed, failed, or skipped, with details about any failures.

:::

## Running tests when code is in separate files but not a package

::: {.python-content}

### Running tests from command line

<!-- When creating the video, I first removed waitingtimes from the conda environment by running pip uninstall waitingtimes -->

When the code you want to test exists in `.py` files but isn't structured as a package, you can still run tests from the terminal or console. You should still have filenames starting with `test_`. in our example video below we have

```
project/
â”œâ”€â”€ patient_analysis.py
â””â”€â”€ test_intro_simple.py
```

to run test, same commands as above

In the video, we:

* Use `tree` to display the file structure - there is just a `.py` file with the `summary_stats()` function, and `test_intro_simple.py` file alongside it.
* Viewing the test file with `nano test_intro_simple.py`, we can see it just locally imports as they are in same folder.
* As it follows the pattern starting `test_`, we can just run with `pytest`.

### Running tests from jupyter notebook

if code is in jupyter notebook, you can use `testbook`.

```{.python}
# Install: pip install testbook
from testbook import testbook

@testbook('my_notebook.ipynb', execute=True)
def test_notebook_function(tb):
    func = tb.ref("add")
    assert func(2, 3) == 5
```

:::

::: {.r-content}

```
project/
â”œâ”€â”€ my_code.R
â””â”€â”€ tests/
    â””â”€â”€ testthat/
        â”œâ”€â”€ test_my_code.R
```

:::

## Running tests in the same file as code

For quick scripts or exploratory work, where you haven't organised code into separate files / modules etc., you may wish to include tests directly in your code file.

dont super recommend...

There are a few options on how you can do this

::: {.python-content}

define tests in script and ...

```{python}
```

in a jupyter notebook use ipytest

```{.python}
# Install: pip install ipytest
import ipytest
ipytest.autoconfig()

# In another cell
def add(a, b):
    return a + b

# In a test cell
%%ipytest
def test_add():
    assert add(2, 3) == 5
```

:::

::: {.r-content}

just write and run them direct in script.

```{.r}
# Function
add <- function(a, b) {
  a + b
}

# Inline test
library(testthat)
test_that("add works correctly", {
  expect_equal(add(2, 3), 5)
  expect_equal(add(-1, 1), 0)
})
```

:::
