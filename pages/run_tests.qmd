---
title: "How to run tests"
---

{{< include /assets/language-selector.html >}}

<br>

::: {.python-content}

The standard and recommended way to run tests in Python is from the terminal using pytest.

## Required structure for running tests from the command line

This approach works when you have:

### 1. Test files that import your analysis code

Your test files need to import the functions, classes, or modules you want to test. This can be done in several ways depending on your project structure:

```{.python}
# If your code is packaged
from waitingtimes.patient_analysis import summary_stats

# If your code is in a local file in the same directory
from patient_analysis import summary_stats

# If your code is in a subdirectory
from src.analysis import summary_stats
```

### 2. Test files following the `test_` naming convention

Pytest automatically discovers and runs tests when your test files start with `test_`. It is also typical (but not mandatory) to store test files in a folder called `tests/`. For example:

```
tests/
â”œâ”€â”€ test_back.py
â”œâ”€â”€ test_functional.py
â””â”€â”€ test_unit.py
```

## Common pytest commands

Once your project follows these conventions, you can run tests from a terminal, PowerShell, or command prompt (depending on your OS). Common commands include:

```{.bash}
# Run all tests in the current directory and subdirectories
pytest

# Run all tests in the tests/ directory
pytest tests/

# Run tests from a specific file
pytest tests/test_filename.py

# Run a specific test function
pytest tests/test_filename.py::test_function_name
```

## Example: package structure

When your code is structured as a package, your project might look like:

```
project/
â”œâ”€â”€ data/
â”‚   â””â”€â”€ patient_data.csv
â”œâ”€â”€ pyproject.toml
â”œâ”€â”€ README.md
â”œâ”€â”€ src/
â”‚   â””â”€â”€ waitingtimes/
â”‚       â”œâ”€â”€ __init__.py
â”‚       â””â”€â”€ patient_analysis.py
â””â”€â”€ tests/
    â”œâ”€â”€ test_intro_simple.py
    â””â”€â”€ ...
```

The video below demonstrates running tests on a package structured this way. In the video we:

* Use `tree`  to display the file structure (matches that shown above).
* Activate our environment: `conda activate hdruk_tests` (which includes pytest).
* Install our local package (if not already installed): `pip install -e .`.
* Verify the installation with `conda list`, confirming our `waitingtimes` package appears.
* Show you the test file (`nano tests/test_intro_simple.py`) (matches the one from the previous page on writing basic tests).
* Run the test with `pytest tests/test_intro_simple.py` - and it passes! ðŸŽ‰

{{< video /videos/run_tests_python_package.webm >}}

If you're unfamiliar with how to set up a package, check out [our tutorial on packaging your research project](https://pythonhealthdatascience.github.io/des_rap_book/pages/guide/setup/package.html).

## Example: Non-package structure

You don't need a full package to use pytest. When you code exists in `.py` files but isn't packaged, you can still run tests from the terminal. Your project might, for example, look like:

```
project/
â”œâ”€â”€ patient_analysis.py
â””â”€â”€ test_intro_simple.py
```

In the video below, we:

* Use `tree` to display the file structure - there is just a `.py` file with the `summary_stats()` function and `test_intro_simple.py` file alongside it.
* View the test file with `nano test_intro_simple.py`, showing it imports locally since files are in the same folder.
* Run the test with `pytest`, since the file follows the `test_` naming pattern.

<!-- When creating the video, I first removed waitingtimes from the conda environment by running pip uninstall waitingtimes -->

{{< video /videos/run_tests_python_pyfiles.webm >}}

## Alternative options

While running tests from the command line is the recommended approach, there are alternative tools for specific use cases.

### testbook

[testbook](https://testbook.readthedocs.io/) allows you to test code within Jupyter notebooks:

```{.python}
# Install: pip install testbook
from testbook import testbook

@testbook('my_notebook.ipynb', execute=True)
def test_notebook_function(tb):
    func = tb.ref("add")
    assert func(2, 3) == 5
```

### ipytest

[ipytest](https://github.com/chmp/ipytest) lets you run pytest directly inside Jupyter notebook cells:

```{.python}
# Install: pip install ipytest
import ipytest
ipytest.autoconfig()

# In another cell
def add(a, b):
    return a + b

# In a test cell
%%ipytest
def test_add():
    assert add(2, 3) == 5
```

### Why command line testing is better

Running tests from the terminal with code organised in `.py` files and a modular structure is the preferred approach because:

* **Test code is separate from analysis code**, making both easier to understand and maintain.

* Tests can be run **automatically in continuous integration (CI)** pipelines, before commits, or on schedule.

* As your project grows, you can **easily add more** test files and organise them logically without cluttering notebooks or scripts.


:::

::: {.r-content}

TODO.

<!-- ROUGH NOTES

Tests are stored in `tests/testthat/` in files starting with `test_`. These are automatically discovered and run by testthat. For example:

```
research_project/
â”œâ”€â”€ DESCRIPTION
â”œâ”€â”€ NAMESPACE
â”œâ”€â”€ README.md
â”œâ”€â”€ R/
â”‚   â”œâ”€â”€ analysis.R
â”‚   â””â”€â”€ utils.R
â””â”€â”€ tests/
    â””â”€â”€ testthat/
        â”œâ”€â”€ test-analysis.R
        â””â”€â”€ test-utils.R
```

Tests are typically run from the R console using the following commands...

```{.r}
# Run all tests in a package
devtools::test()

# Run all tests in the current directory and subdirectories
testthat::test_dir()

# Run tests from a specific file
testthat:test_file("tests/testthat/test-filename.R")
```

When tests run, you'll see console output indicating the number of tests passed, failed, or skipped, with details about any failures.

```
project/
â”œâ”€â”€ my_code.R
â””â”€â”€ tests/
    â””â”€â”€ testthat/
        â”œâ”€â”€ test_my_code.R
```

just write and run them direct in script.

```{.r}
# Function
add <- function(a, b) {
  a + b
}

# Inline test
library(testthat)
test_that("add works correctly", {
  expect_equal(add(2, 3), 5)
  expect_equal(add(-1, 1), 0)
})
```

-->

:::
