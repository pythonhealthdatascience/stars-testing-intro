---
title: "How to run tests"
---

{{< include /assets/language-selector.html >}}

<br>

::: {.python-content}

The standard and recommended way to run tests in Python is from the **terminal** using pytest.

## Required structure for running tests from the command line

This approach works when you have:

### 1. Test files that import your analysis code

Your test files need to import the functions, classes, or modules you want to test. This can be done in several ways depending on your project structure:

```{.python}
# If your code is packaged
from waitingtimes.patient_analysis import summary_stats

# If your code is in a local file in the same directory
from patient_analysis import summary_stats

# If your code is in a subdirectory
from src.analysis import summary_stats
```

### 2. Test files following the `test_` naming convention

Pytest automatically discovers and runs tests when your test files start with `test_`. It is also typical (but not mandatory) to store test files in a folder called `tests/`. For example:

```
tests/
â”œâ”€â”€ test_regression.py
â”œâ”€â”€ test_system.py
â””â”€â”€ test_unit.py
```

## Common pytest commands

Once your project follows these conventions, you can run tests from a terminal, PowerShell, or command prompt (depending on your OS). Common commands include:

```{.bash}
# Run all tests in the current directory and subdirectories
pytest

# Run all tests in the tests/ directory
pytest tests/

# Run tests from a specific file
pytest tests/test_filename.py

# Run a specific test function
pytest tests/test_filename.py::test_function_name
```

:::

::: {.r-content}

The standard and recommended way to run tests in R is from the **R console**, running them either via `devtools` or directly with `testthat`.

:::

## Example: package structure

::: {.python-content}

When your code is structured as a package, your project might look like:

```
project/
â”œâ”€â”€ data/
â”‚   â””â”€â”€ patient_data.csv
â”œâ”€â”€ pyproject.toml
â”œâ”€â”€ README.md
â”œâ”€â”€ src/
â”‚   â””â”€â”€ waitingtimes/
â”‚       â”œâ”€â”€ __init__.py
â”‚       â””â”€â”€ patient_analysis.py
â””â”€â”€ tests/
    â”œâ”€â”€ test_intro_simple.py
    â””â”€â”€ ...
```

The video below demonstrates running tests on a package structured this way. In the video we:

* Use `tree`  to display the file structure (matches that shown above).
* Activate our environment: `conda activate stars-testing-intro` (which includes pytest).
* Install our local package (if not already installed): `pip install -e .`.
* Verify the installation with `conda list`, confirming our `waitingtimes` package appears.
* Show you the test file (`nano tests/test_intro_simple.py`) (matches the one from the previous page on writing basic tests).
* Run the test with `pytest tests/test_intro_simple.py` - and it passes! ðŸŽ‰

{{< video /videos/run_tests_python_package.webm >}}

:::

::: {.r-content}

In an R package, tests will be automatically discovered and run if they follow the conventions of being:

1. Stored within `tests/testthat/`.
2. In R files starting with `test_` or `test-`.

For example, your project might look like:

```
project/
â”œâ”€â”€ inst/
â”‚   â””â”€â”€ extdata/
â”‚       â””â”€â”€ patient_data.csv
â”œâ”€â”€ man/
â”‚   â””â”€â”€ ...
â”œâ”€â”€ R/
â”‚   â””â”€â”€ patient_analysis.R
â”œâ”€â”€ tests/
â”‚   â””â”€â”€ testthat/
â”‚       â”œâ”€â”€ test_intro_simple.R
â”‚       â””â”€â”€ ...
â”œâ”€â”€ .Rbuildignore
â”œâ”€â”€ DESCRIPTION
â”œâ”€â”€ LICENSE
â”œâ”€â”€ LICENSE.md
â”œâ”€â”€ NAMESPACE
â””â”€â”€ README.md
```

You can either run the tests with `devtools` or `testthat` - common commands include:

```{.r}
# Run all tests in the package
devtools::test()

# Run all tests in the named file
testthat::test_file("tests/testthat/test-patient_analysis.R")

# Run all tests in that directory
testthat::test_dir("tests/testthat")
```

In the video below, we have an example of a research project structured as an our R project.

* We highlight that the renv is active (`Project '~/Documents/stars/stars-testing-intro' loaded. [renv 1.1.5]`).
* We show the test file we will be running (`test_intro_simple.R`).
* We run `devtools::test()` and can see that all tests pass.

{{< video /videos/run_tests_r_package.webm >}}

:::

If you're unfamiliar with how to set up a package, check out [our tutorial on packaging your research project](https://pythonhealthdatascience.github.io/des_rap_book/pages/guide/setup/package.html).

## Example: Non-package structure

::: {.python-content}

You don't need a full package to use pytest. When your code exists in `.py` files but isn't packaged, you can still run tests from the terminal. Your project might, for example, look like:

```
project/
â”œâ”€â”€ patient_analysis.py
â””â”€â”€ test_intro_simple.py
```

In the video below, we:

* Use `tree` to display the file structure - there is just a `.py` file with the `summary_stats()` function and `test_intro_simple.py` file alongside it.
* View the test file with `nano test_intro_simple.py`, showing it imports locally since files are in the same folder.
* Run the test with `pytest`, since the file follows the `test_` naming pattern.

<!-- When creating the video, I first removed waitingtimes from the conda environment by running pip uninstall waitingtimes -->

{{< video /videos/run_tests_python_pyfiles.webm >}}

:::

::: {.r-content}

You don't need a full package to use testthat. When your code exists in `.R` files but isn't packaged, you can still run tests from the R console. You project might, for example, look like:

```
project/
â”œâ”€â”€ patient_analysis.R
â””â”€â”€ test_intro_simple.R
```

As your test follows of the convention of starting `test_`, it can still be detected by `testthat` and run by `testthat:test_dir()` or `testthat::test_file()`.

> Note: You cannot use `devtools::test()` with this approach.

In the video below, we:

* Open the `test_intro_simple.R` file, showing how it imports the local function.
* Run `testthat::test_dir(".")`, which finds and runs our test.

{{< video /videos/run_tests_r_rfiles.webm >}}

:::

## Alternative options

::: {.python-content}

While running tests from the command line is the recommended approach, there are alternative tools for specific use cases.

### testbook

[testbook](https://testbook.readthedocs.io/) allows you to test code within Jupyter notebooks:

```{.python}
# Install: pip install testbook
from testbook import testbook

@testbook('my_notebook.ipynb', execute=True)
def test_notebook_function(tb):
    func = tb.ref("add")
    assert func(2, 3) == 5
```

### ipytest

[ipytest](https://github.com/chmp/ipytest) lets you run pytest directly inside Jupyter notebook cells:

```{.python}
# Install: pip install ipytest
import ipytest
ipytest.autoconfig()

# In another cell
def add(a, b):
    return a + b

# In a test cell
%%ipytest
def test_add():
    assert add(2, 3) == 5
```

:::

::: {.r-content}

While running tests from the R console is the recommended approach, it is also possible to put tests directly in the same `.R` file as your code and just run the script.

For example:

```{r}
# add.R

add <- function(a, b) {
  a + b
}

library(testthat)

test_that("add works correctly", {
  expect_equal(add(2, 3), 5)
  expect_equal(add(-1, 1), 0)
})
```

:::

### Why command line testing is better

Running tests from the terminal with code organised into separate files  is the preferred approach because:

* **Test code is separate from analysis code**, making both easier to understand and maintain.

* Tests can be run **automatically in continuous integration (CI)** pipelines, before commits, or on schedule.

* As your project grows, you can **easily add more** test files and organise them logically without cluttering notebooks or scripts.
