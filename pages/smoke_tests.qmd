---
title: "Smoke tests"
---

```{r}
#| include: false
library(reticulate)
use_condaenv("stars-testing-intro", required = TRUE)
```

{{< include /assets/language-selector.html >}}

## What is a smoke test?

**Smoke tests** (also known as **build verification tests**) are a "sanity check" run before a complete test suite. They are extremely quick and just test that the code can run end-to-end, and not that the results are correct.

If a smoke test fails, it usually means something fundamental is broken (for example, a missing dependency, a changed column name, or a syntax error). In that case, there is no point running slower, more detailed tests until the basic problem is fixed.

## Example: waiting times case study

We will create a simple smoke test for our case study workflow. This workflow uses three functions: 

* `import_patient_data()` - reads patient data from CSV.
* `calculate_wait_times()` - calculates wait times.
* `summary_stats()` - produces summary statistics.

For the smoke test, we do not care whether the CSV, wait times or statistics are correct. We only care that each function is able to run successfully, and that at least something is returned.

::: {.python-content}

We will need the following imports in our test script:

```{python}
#| eval: false
#| file: code/test_smoke__imports.py
```

:::

## Smoke test

In the test, we build a **tiny dummy dataset** so that the test runs quickly.

:::: {.python-content}

We use pytest's `tmp_path` fixture, which gives us a **temporary folder** that is created for the test and automatically cleaned up afterwards, so we do not touch any real files on your machine.

We then run the full workflow end-to-end, and finish with a minimal assertion: checking only that `stats` exists.

```{python}
#| eval: false
#| file: code/test_smoke__test_smoke.py
```

::: {.callout-tip title="What is a fixture?"}

In pytest, a **fixture** is a small helper function that prepares something your test needs and then passes it into the test function as a parameter.

When you write a test like `def test_name(tmp_path):`, the name `tmp_path` tells pytest to call its built-in `tmp_path` fixture first. Whatever that fixture returns is then given to the test as the `tmp_path` argument.

In this case, the fixture creates a temporary folder and passes a path object called `tmp_path` into the test. At the end of the test, pytest removes that folder, so you do not leave any files behind.

:::

::::

::: {.r-content}

We write it to a temporary file using `tempfile()`, so we do not touch any real files on your machine.

We then run the full workflow end-to-end, and finish with a minimal expectation: checking only that `stats` exists.

```{r}
#| eval: false
#| file: code/test_smoke__smoke_end_to_end_workflow.R
```

:::

## How to run the smoke test

You can run only the smoke test file with:

::: {.python-content}

```{.bash}
pytest test_smoke.py
```

However, you may wish to treat the smoke test as a **gate** - i.e., if that test fails, no others are run. So, instead of just calling `pytest` when running your test suite, you can call:

```{.bash}
pytest test_smoke.py && pytest --ignore=test_smoke.py
```

:::

::: {.r-content}

```{.r}
testthat::test_file("tests/testthat/test_smoke.R")
```

However, you may wish to treat the smoke test as a **gate** - i.e., if that test fails, no others are run. So, instead of just calling `devtools::test()` when running your test suite, you can create a `Makefile`:

```{.bash}
test:
	Rscript -e "testthat::test_file('tests/testthat/test_smoke.R')" && \
	Rscript -e "devtools::test()"
```

This is then run by calling:

```{.bash}
make test
```

:::

This works as follows:

* The first command runs the smoke test.
* `&&` means "only run the next command if the previous one succeeded".
* The second command runs the full test suite.

If the smoke test fails, the second command is never run, so the full test suite is not executed.

## Running our example test

:::: {.callout-note title="Test output"}

::: {.python-content}

```{python}
#| echo: false
import pytest
pytest.main(["../examples/python_package/tests/test_smoke.py"])
```

:::

::: {.r-content}

```{r}
#| echo: false
#| output: false
devtools::load_all("../examples/r_package")
```

```{r}
#| echo: false
testthat::test_file(
  "../examples/r_package/tests/testthat/test_smoke.R"
)
```

:::

::::
